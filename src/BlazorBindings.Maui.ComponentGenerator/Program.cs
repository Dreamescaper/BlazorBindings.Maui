// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using BlazorBindings.Maui.ComponentGenerator.Extensions;
using CommandLine;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace BlazorBindings.Maui.ComponentGenerator;

public class Program
{
    const string FileHeader = @"// <auto-generated>
//     This code was generated by a BlazorBindings.Maui component generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
";

    public static async Task Main(string[] args)
    {
        MSBuildLocator.RegisterInstance(MSBuildLocator.QueryVisualStudioInstances().MaxBy(instance => instance.Version));

        await Parser.Default
            .ParseArguments<Options>(args)
            .WithParsedAsync(async o =>
            {
                if (o.ProjectPath is null)
                {
                    o.ProjectPath = Directory.GetFiles(Directory.GetCurrentDirectory()).FirstOrDefault(f
                        => f.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
                        ?? throw new Exception("Cannot find any csproj files.");
                }
                if (o.OutPath is null)
                {
                    o.OutPath = Path.Combine(o.ProjectPath, "..", "Elements");
                }

                var compilation = await CreateComplitation(o);

                var typesToGenerate = GetTypesToGenerate(compilation);

                Console.WriteLine($"Generating {typesToGenerate.Length} files.");

                var componentWrapperGenerator = new ComponentWrapperGenerator();

                foreach (var generatedType in typesToGenerate)
                {
                    var (groupName, name, source) = componentWrapperGenerator.GenerateComponentFile(compilation, generatedType);

                    var fileName = $"{name}.generated.cs";
                    var path = string.IsNullOrEmpty(groupName)
                        ? Path.Combine(o.OutPath, fileName)
                        : Path.Combine(o.OutPath, groupName, fileName);

                    Directory.GetParent(path).Create();

                    File.WriteAllText(path, source);
                }
            });
    }

    private static GenerateComponentSettings[] GetTypesToGenerate(Compilation compilation)
    {
        Console.WriteLine("Finding types to generate.");

        var elementType = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.Element");

        var attributes = compilation.Assembly.GetAttributes();
        var typesToGenerate = attributes
            .Where(a => a.AttributeClass?.ToDisplayString() == "BlazorBindings.Maui.ComponentGenerator.GenerateComponentAttribute")
            .Select(a =>
            {
                var typeSymbol = a.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol;

                var propertiesAliases = GetNamedArgumentValues(a, "Aliases")
                    .Select(v => v.Split(':'))
                    .ToDictionary(v => v[0], v => v[1]);

                // Type alias has type name as a key.
                propertiesAliases.Remove(typeSymbol.Name, out var typeAlias);

                return new GenerateComponentSettings
                {
                    FileHeader = FileHeader,
                    TypeAlias = typeAlias,
                    TypeSymbol = typeSymbol,
                    Exclude = GetNamedArgumentValues(a, "Exclude").ToHashSet(),
                    Include = GetNamedArgumentValues(a, "Include").ToHashSet(),
                    ContentProperties = GetNamedArgumentValues(a, "ContentProperties").ToHashSet(),
                    NonContentProperties = GetNamedArgumentValues(a, "NonContentProperties").ToHashSet(),
                    PropertyChangedEvents = GetNamedArgumentValues(a, "PropertyChangedEvents"),
                    GenericProperties = GetNamedArgumentValues(a, "GenericProperties").Select(v => v.Split(':')).ToDictionary(v => v[0],
                        v => v.ElementAtOrDefault(1) is string genericArgName ? compilation.GetTypeByMetadataName(genericArgName) : null),
                    Aliases = propertiesAliases,
                    IsGeneric = (a.NamedArguments.FirstOrDefault(a => a.Key == "IsGeneric").Value.Value as bool?) ?? false
                };
            })
            .Where(type => type.TypeSymbol != null)
            .ToList();

        var typesByAssembly = attributes
            .Where(a => a.AttributeClass?.ToDisplayString() == "BlazorBindings.Maui.ComponentGenerator.GenerateComponentsFromAssemblyAttribute")
            .SelectMany(a =>
            {
                var containingTypeSymbol = a.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol;
                var typeNamePrefix = a.NamedArguments.FirstOrDefault(a => a.Key == "TypeNamePrefix").Value.Value as string;

                var typesInAssembly = containingTypeSymbol.ContainingAssembly
                    .GlobalNamespace.GetAllTypes()
                    .Where(t => t.DeclaredAccessibility == Accessibility.Public)
                    .Where(t => !(t.IsGenericType && t.IsDefinition))
                    .Where(t => compilation.ClassifyCommonConversion(t, elementType) is { IsReference: true, IsImplicit: true });

                return typesInAssembly
                    .Where(typeSymbol => !typesToGenerate.Any(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, typeSymbol)))
                    .Select(typeSymbol => new GenerateComponentSettings
                    {
                        FileHeader = FileHeader,
                        TypeSymbol = typeSymbol,
                        TypeAlias = typeNamePrefix is null ? null : typeNamePrefix + typeSymbol.Name
                    });
            });

        typesToGenerate.AddRange(typesByAssembly);

        foreach (var info in typesToGenerate)
        {
            var baseTypeInfo = typesToGenerate.FirstOrDefault(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, info.TypeSymbol?.BaseType));
            info.BaseTypeInfo = baseTypeInfo;
        }

        return typesToGenerate.ToArray();
    }

    private static string[] GetNamedArgumentValues(AttributeData attribute, string name)
    {
        var argumentConstant = attribute.NamedArguments.FirstOrDefault(a => a.Key == name).Value;

        if (argumentConstant.Kind != TypedConstantKind.Array)
            return Array.Empty<string>();

        var values = argumentConstant.Values;

        if (values.IsDefaultOrEmpty)
            return Array.Empty<string>();

        return values.Select(a => a.Value as string).Where(v => v is not null).ToArray();
    }

    private static async Task<Compilation> CreateComplitation(Options o)
    {
        Console.WriteLine("Creating project compilation.");

        var workspace = MSBuildWorkspace.Create();
        var project = await workspace.OpenProjectAsync(o.ProjectPath);
        var compilation = await project.GetCompilationAsync();

        return compilation;
    }

    private class Options
    {
        [Value(0, HelpText = "Project file path to run generator.")]
        public string ProjectPath { get; set; }

        [Option('o', "out-path", HelpText = "Out path for generated files.")]
        public string OutPath { get; set; }
    }
}
