// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using CommandLine;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace BlazorBindings.Maui.ComponentGenerator
{
    public class Program
    {
        const string FileHeader = @"// <auto-generated>
//     This code was generated by a BlazorBindings.Maui component generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
";

        public static async Task Main(string[] args)
        {
            MSBuildLocator.RegisterInstance(MSBuildLocator.QueryVisualStudioInstances().MaxBy(instance => instance.Version));

            await Parser.Default
                .ParseArguments<Options>(args)
                .WithParsedAsync(async o =>
                {
                    if (o.ProjectPath is null)
                    {
                        o.ProjectPath = Directory.GetFiles(Directory.GetCurrentDirectory()).FirstOrDefault(f
                            => f.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
                            ?? throw new Exception("Cannot find any csproj files.");
                    }
                    if (o.OutPath is null)
                    {
                        o.OutPath = Path.Combine(o.ProjectPath, "..", "Elements");
                    }

                    var compilation = await CreateComplitation(o);

                    var typesToGenerate = GetTypesToGenerate(compilation);

                    Console.WriteLine($"Generating {typesToGenerate.Length} files.");

                    var componentWrapperGenerator = new ComponentWrapperGenerator();

                    foreach (var generatedType in typesToGenerate)
                    {
                        var (groupName, name, source) = componentWrapperGenerator.GenerateComponentFile(compilation, generatedType);

                        var fileName = $"{name}.generated.cs";
                        var path = string.IsNullOrEmpty(groupName)
                            ? Path.Combine(o.OutPath, fileName)
                            : Path.Combine(o.OutPath, groupName, fileName);

                        Directory.GetParent(path).Create();

                        File.WriteAllText(path, source);
                    }
                });
        }

        private static GenerateComponentSettings[] GetTypesToGenerate(Compilation compilation)
        {
            Console.WriteLine("Finding types to generate.");

            var attributes = compilation.Assembly.GetAttributes();
            var typesToGenerate = attributes
                .Where(a => a.AttributeClass?.ToDisplayString() == "BlazorBindings.Maui.ComponentGenerator.GenerateComponentAttribute")
                .Select(a =>
                {
                    var typeSymbol = a.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol;

                    var propertiesAliases = GetNamedArgumentValues(a, "Aliases")
                        .Select(v => v.Split(':'))
                        .ToDictionary(v => v[0], v => v[1]);

                    // Type alias has type name as a key.
                    propertiesAliases.Remove(typeSymbol.Name, out var typeAlias);

                    return new GenerateComponentSettings
                    {
                        FileHeader = FileHeader,
                        TypeAlias = typeAlias,
                        TypeSymbol = typeSymbol,
                        Exclude = GetNamedArgumentValues(a, "Exclude").ToHashSet(),
                        Include = GetNamedArgumentValues(a, "Include").ToHashSet(),
                        ContentProperties = GetNamedArgumentValues(a, "ContentProperties").ToHashSet(),
                        PropertyChangedEvents = GetNamedArgumentValues(a, "PropertyChangedEvents"),
                        GenericProperties = GetNamedArgumentValues(a, "GenericProperties").Select(v => v.Split(':')).ToDictionary(v => v[0],
                            v => v.ElementAtOrDefault(1) is string genericArgName ? compilation.GetTypeByMetadataName(genericArgName) : null),
                        Aliases = propertiesAliases,
                        IsGeneric = (a.NamedArguments.FirstOrDefault(a => a.Key == "IsGeneric").Value.Value as bool?) ?? false
                    };
                })
                .Where(type => type.TypeSymbol != null)
                .ToArray();

            foreach (var info in typesToGenerate)
            {
                var baseTypeInfo = typesToGenerate.FirstOrDefault(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, info.TypeSymbol?.BaseType));
                info.BaseTypeInfo = baseTypeInfo;
            }

            return typesToGenerate;
        }

        private static string[] GetNamedArgumentValues(AttributeData attribute, string name)
        {
            var argumentConstant = attribute.NamedArguments.FirstOrDefault(a => a.Key == name).Value;

            if (argumentConstant.Kind != TypedConstantKind.Array)
                return Array.Empty<string>();

            var values = argumentConstant.Values;

            if (values.IsDefaultOrEmpty)
                return Array.Empty<string>();

            return values.Select(a => a.Value as string).Where(v => v is not null).ToArray();
        }

        private static async Task<Compilation> CreateComplitation(Options o)
        {
            Console.WriteLine("Creating project compilation.");

            var workspace = MSBuildWorkspace.Create();
            var project = await workspace.OpenProjectAsync(o.ProjectPath);
            var compilation = await project.GetCompilationAsync();

            return compilation;
        }

        private class Options
        {
            [Value(0, HelpText = "Project file path to run generator.")]
            public string ProjectPath { get; set; }

            [Option('o', "out-path", HelpText = "Out path for generated files.")]
            public string OutPath { get; set; }
        }
    }
}
