// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using BlazorBindings.Maui.ComponentGenerator.Extensions;
using BlazorBindings.Maui.ComponentGenerator.Model;
using CommandLine;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using System.Collections;

namespace BlazorBindings.Maui.ComponentGenerator;

public class Program
{
    const string FileHeader = """
        // <auto-generated>
        //     This code was generated by a BlazorBindings.Maui component generator.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>

        """;

    public static async Task Main(string[] args)
    {
        MSBuildLocator.RegisterInstance(MSBuildLocator.QueryVisualStudioInstances().MaxBy(instance => instance.Version));

        await Parser.Default
            .ParseArguments<Options>(args)
            .WithParsedAsync(async o =>
            {
                o.ProjectPath ??= Directory.GetFiles(Directory.GetCurrentDirectory())
                        .FirstOrDefault(f => f.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
                    ?? throw new ArgumentException("Cannot find any csproj files.");

                o.OutPath ??= Path.Combine(o.ProjectPath, "..", "Elements");

                var compilation = await CreateCompilation(o);

                var typesToGenerate = GetTypesToGenerate(compilation);

                var componentWrapperGenerator = new ComponentWrapperGenerator();
                var generatedTypes = GeneratedTypeInfo.Create(compilation, typesToGenerate);

                if (!o.KeepExistingFiles)
                {
                    DeleteExistingFiles(o.OutPath);
                }

                Console.WriteLine($"Generating {generatedTypes.Count} files.");
                foreach (var generatedType in generatedTypes)
                {
                    var source = componentWrapperGenerator.GenerateComponentFileSource(generatedType);

                    var fileName = $"{generatedType.TypeName}.generated.cs";
                    var path = string.IsNullOrEmpty(generatedType.ComponentGroup)
                        ? Path.Combine(o.OutPath, fileName)
                        : Path.Combine(o.OutPath, generatedType.ComponentGroup, fileName);

                    Directory.GetParent(path).Create();

                    File.WriteAllText(path, source);
                }
            });
    }

    private static void DeleteExistingFiles(string path)
    {
        if (!Directory.Exists(path))
            return;

        var generatedFiles = Directory.EnumerateFiles(path, "*.generated.cs", SearchOption.AllDirectories);
        foreach (var generatedFile in generatedFiles)
        {
            File.Delete(generatedFile);
        }
    }

    private static List<GenerateComponentSettings> GetTypesToGenerate(Compilation compilation)
    {
        Console.WriteLine("Finding types to generate.");

        var elementType = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.Element");
        var bindableObjectType = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.BindableObject");

        var attributes = compilation.Assembly.GetAttributes();
        var typesToGenerate = attributes
            .Where(a => a.AttributeClass?.ToDisplayString() == "BlazorBindings.Maui.ComponentGenerator.GenerateComponentAttribute")
            .Select(a =>
            {
                var typeSymbol = a.ConstructorArguments.First().Value as INamedTypeSymbol;

                var propertiesAliases = GetNamedArgumentValues(a, "Aliases")
                    .Select(v => v.Split(':'))
                    .ToDictionary(v => v[0], v => v[1]);

                // Type alias has type name as a key.
                propertiesAliases.Remove(typeSymbol?.Name, out var typeAlias);

                return new GenerateComponentSettings
                {
                    FileHeader = FileHeader,
                    TypeAlias = typeAlias,
                    TypeSymbol = typeSymbol!,
                    Exclude = [.. GetNamedArgumentValues(a, "Exclude")],
                    Include = [.. GetNamedArgumentValues(a, "Include")],
                    ContentProperties = [.. GetNamedArgumentValues(a, "ContentProperties")],
                    NonContentProperties = [.. GetNamedArgumentValues(a, "NonContentProperties")],
                    PropertyChangedEvents = GetNamedArgumentValues(a, "PropertyChangedEvents"),
                    GenericProperties = GetNamedArgumentValues(a, "GenericProperties").Select(v => v.Split(':')).ToDictionary(v => v[0],
                        v => v.ElementAtOrDefault(1) is string genericArgName ? compilation.GetTypeByMetadataName(genericArgName) : null),
                    Aliases = propertiesAliases,
                    IsGeneric = a.NamedArguments.FirstOrDefault(a => a.Key == "IsGeneric").Value.Value as bool? ?? false
                };
            })
            .Where(type => type.TypeSymbol != null)
            .ToList();

        var typesByAssembly = attributes
            .Where(a => a.AttributeClass?.ToDisplayString() == "BlazorBindings.Maui.ComponentGenerator.GenerateComponentsFromAssemblyAttribute")
            .SelectMany(a =>
            {
                var containingTypeSymbol = a.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol;
                var typeNamePrefix = a.NamedArguments.FirstOrDefault(a => a.Key == "TypeNamePrefix").Value.Value as string;
                var includeNonElements = a.NamedArguments.FirstOrDefault(a => a.Key == "IncludeNonElements").Value.Value as bool?;
                var excludeTypes = a.NamedArguments.FirstOrDefault(a => a.Key == "Exclude").Value is { Kind: TypedConstantKind.Array } array
                    ? array.Values.Select(v => (INamedTypeSymbol)v.Value).ToArray()
                    : [];

                var requiredBaseType = includeNonElements == true ? bindableObjectType : elementType;

                var typesInAssembly = containingTypeSymbol.ContainingAssembly
                    .GlobalNamespace.GetAllTypes()
                    .Where(t => t.DeclaredAccessibility == Accessibility.Public && t.IsBrowsable() && !t.IsObsolete())
                    .Where(t => !(t.IsGenericType && t.IsDefinition))
                    .Where(t => !excludeTypes.Any(excludeType => SymbolEqualityComparer.Default.Equals(excludeType, t)))
                    .Where(t => compilation.ClassifyCommonConversion(t, requiredBaseType) is { IsReference: true, IsImplicit: true });

                return typesInAssembly
                    .Where(typeSymbol => !typesToGenerate.Any(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, typeSymbol)))
                    .Select(typeSymbol => new GenerateComponentSettings
                    {
                        FileHeader = FileHeader,
                        TypeSymbol = typeSymbol,
                        TypeAlias = typeNamePrefix is null ? null : typeNamePrefix + typeSymbol.Name
                    });
            });

        typesToGenerate.AddRange(typesByAssembly);

        return typesToGenerate;
    }

    private static string[] GetNamedArgumentValues(AttributeData attribute, string name)
    {
        var argumentConstant = attribute.NamedArguments.FirstOrDefault(a => a.Key == name).Value;

        if (argumentConstant.Kind != TypedConstantKind.Array)
            return [];

        var values = argumentConstant.Values;

        if (values.IsDefaultOrEmpty)
            return [];

        return values.Select(a => a.Value as string).Where(v => v is not null).ToArray();
    }

    private static async Task<Compilation> CreateCompilation(Options o)
    {
        Console.WriteLine("Creating project compilation.");

        var workspace = MSBuildWorkspace.Create();
        var project = await workspace.OpenProjectAsync(o.ProjectPath);
        var compilation = await project.GetCompilationAsync();

        return compilation;
    }

    private sealed class Options
    {
        [Value(0, HelpText = "Project file path to run generator.")]
        public string ProjectPath { get; set; }

        [Option('o', "out-path", HelpText = "Out path for generated files.")]
        public string OutPath { get; set; }

        [Option("keep-existing-files", Default = false, HelpText = "Do not remove files from previous generations.")]
        public bool KeepExistingFiles { get; set; }
    }
}