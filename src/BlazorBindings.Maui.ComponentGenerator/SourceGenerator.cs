// Unfortunately, source generator approach doesn't really work with razor files so far.

#if FALSE

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;

namespace BlazorBindings.Maui.ComponentGenerator
{
    [Generator]
    public class SourceGenerator : IIncrementalGenerator
    {
        private static readonly ComponentWrapperGenerator componentWrapperGenerator = new(
            new GeneratorSettings
            {
                FileHeader = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a BlazorBindings.Maui component generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
"
            });

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var enumDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s), // Select assembly targeted attributes.
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m != null);

            var compilationAndEnums = context.CompilationProvider.Combine(enumDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndEnums,
                static (spc, source) => Execute(source.Left, source.Right, spc));
        }

        static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is AttributeSyntax attribute
                && attribute.Parent is AttributeListSyntax attributeList
                && attributeList.Target?.Identifier.IsKind(SyntaxKind.AssemblyKeyword) == true;
        }

        static GeneratedComponentInfo GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;

            if (attributeSyntax.ArgumentList.Arguments.FirstOrDefault()?.Expression is not TypeOfExpressionSyntax typeOf)
                return null;

            var attributeTypeSymbol = context.SemanticModel.GetTypeInfo(attributeSyntax).Type;

            if (attributeTypeSymbol?.ToDisplayString() != "BlazorBindings.Maui.ComponentGenerator.GenerateComponentAttribute")
                return null;

            var typeSymbol = context.SemanticModel.GetSymbolInfo(typeOf.Type).Symbol;

            if (typeSymbol is not INamedTypeSymbol namedTypeSymbol)
                return null;

            return new GeneratedComponentInfo
            {
                TypeSymbol = namedTypeSymbol
            };
        }

        static void Execute(Compilation compilation, ImmutableArray<GeneratedComponentInfo> types, SourceProductionContext context)
        {
            foreach (var generatedInfo in types)
            {
                var (groupName, name, source) = componentWrapperGenerator.GenerateComponentFile(compilation, generatedInfo);
                var hintName = string.IsNullOrEmpty(groupName) ? $"{name}.generated.cs" : $"{groupName}.{name}.generated.cs";
                context.AddSource(hintName, source);
            }
        }
    }
}
#endif